import{_ as e,a as t,b as n}from"./00019-TNWAwblU.js";import{_ as a,o,c as s,e as i}from"./app-Dre1b5M6.js";const r={},l=i('<h1 id="chapter-9-better-together-or-better-apart" tabindex="-1"><a class="header-anchor" href="#chapter-9-better-together-or-better-apart"><span>Chapter 9 Better Together Or Better Apart?</span></a></h1><p>One of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated? This question applies at all levels in a system, such as functions, methods, classes, and services. For example, should buffering be included in the class that provides stream-oriented file I/O, or should it be in a separate class? Should the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)? This chapter discusses the factors to consider when making these decisions. Some of these factors have already been discussed in previous chapters, but they will be revisited here for completeness.</p><p>When deciding whether to combine or separate, the goal is to reduce the complexity of the system as a whole and improve its modularity. It might appear that the best way to achieve this goal is to divide the system into a large number of small components: the smaller the components, the simpler each individual component is likely to be. However, the act of subdividing creates additional complexity that was not present before subdivision:</p><ul><li>Some complexity comes just from the number of components: the more components, the harder to keep track of them all and the harder to find a desired component within the large collection. Subdivision usually results in more interfaces, and every new interface adds complexity.</li><li>Subdivision can result in additional code to manage the components. For example, a piece of code that used a single object before subdivision might now have to manage multiple objects.</li><li>Subdivision creates separation: the subdivided components will be farther apart than they were before subdivision. For example, methods that were together in a single class before subdivision may be in different classes after subdivision, and possibly in different files. Separation makes it harder for developers to see the components at the same time, or even to be aware of their existence. If the components are truly independent, then separation is good: it allows the developer to focus on a single component at a time, without being distracted by the other components. On the other hand, if there are dependencies between the components, then separation is bad: developers will end up flipping back and forth between the components. Even worse, they may not be aware of the dependencies, which can lead to bugs.</li><li>Subdivision can result in duplication: code that was present in a single instance before subdivision may need to be present in each of the subdivided components.</li></ul><p>Bringing pieces of code together is most beneficial if they are closely related. If the pieces are unrelated, they are probably better off apart. Here are a few indications that two pieces of code are related:</p><ul><li>They share information; for example, both pieces of code might depend on the syntax of a particular type of document.</li><li>They are used together: anyone using one of the pieces of code is likely to use the other as well. This form of relationship is only compelling if it is bidirectional. As a counter-example, a disk block cache will almost always involve a hash table, but hash tables can be used in many situations that don’t involve block caches; thus, these modules should be separate.</li><li>They overlap conceptually, in that there is a simple higher-level category that includes both of the pieces of code. For example, searching for a substring and case conversion both fall under the category of string manipulation; flow control and reliable delivery both fall under the category of network communication.</li><li>It is hard to understand one of the pieces of code without looking at the other.</li></ul><p>The rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.</p><h2 id="_9-1-bring-together-if-information-is-shared" tabindex="-1"><a class="header-anchor" href="#_9-1-bring-together-if-information-is-shared"><span>9.1 Bring together if information is shared</span></a></h2><p>Section 5.4 introduced this principle in the context of a project implementing an HTTP server. In its first implementation, the project used two different methods in different classes to read in and parse HTTP requests. The first method read the text of an incoming request from a network socket and placed it in a string object. The second method parsed the string to extract the various components of the request. With this decomposition, both of the methods ended up with considerable knowledge of the format of HTTP requests: the first method was only trying to read the request, not parse it, but it couldn’t identify the end of the request without doing most of the work of parsing it (for example, it had to parse header lines in order to identify the header containing the overall request length). Because of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.</p><h2 id="_9-2-bring-together-if-it-will-simplify-the-interface" tabindex="-1"><a class="header-anchor" href="#_9-2-bring-together-if-it-will-simplify-the-interface"><span>9.2 Bring together if it will simplify the interface</span></a></h2><p>When two or more modules are combined into a single module, it may be possible to define an interface for the new module that is simpler or easier to use than the original interfaces. This often happens when the original modules each implement part of the solution to a problem. In the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second. When the methods were combined, these interfaces were eliminated.</p><p>In addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them. The Java I/O library illustrates this opportunity. If the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering. A combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.</p><h2 id="_9-3-bring-together-to-eliminate-duplication" tabindex="-1"><a class="header-anchor" href="#_9-3-bring-together-to-eliminate-duplication"><span>9.3 Bring together to eliminate duplication</span></a></h2><p>If you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeated code out into a separate method and replace the repeated code snippets with calls to the method. This approach is most effective if the repeated code snippet is long and the replacement method has a simple signature. If the snippet is only one or two lines long, there may not be much benefit in replacing it with a method call. If the snippet interacts in complex ways with its environment (such as by accessing numerous local variables), then the replacement method might require a complex signature (such as many pass-by-reference arguments), which would reduce its value.</p><p>Another way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writing a method that needs to return errors at several different points, and the same cleanup actions need to be performed at each of these points before returning (see Figure 9.1 for an example). If the programming language supports goto, you can move the cleanup code to the very end of the method and then goto that snippet at each of the points where an error return is required, as in Figure 9.2. Goto statements are generally considered a bad idea, and they can result in indecipherable code if used indiscriminately, but they are useful in situations like this where they are used to escape from nested code.</p><h2 id="_9-4-separate-general-purpose-and-special-purpose-code" tabindex="-1"><a class="header-anchor" href="#_9-4-separate-general-purpose-and-special-purpose-code"><span>9.4 Separate general-purpose and special-purpose code</span></a></h2><p>If a module contains a mechanism that can be used for several different purposes, then it should provide just that one general-purpose mechanism. It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typically one associated with the particular purpose). The GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the selection) were implemented in the user interface module. This approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.</p><p>img Red Flag: Repetition img</p><p>If the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.</p><p><img src="'+e+'" alt=""></p><p>Figure 9.1: This code processes incoming network packets of different types; for each type, if the packet is too short for that type, a message gets logged. In this version of the code, the LOG statement is duplicated for several different packet types.</p><p><img src="'+t+`" alt=""></p><p>Figure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement.</p><h2 id="_9-5-example-insertion-cursor-and-selection" tabindex="-1"><a class="header-anchor" href="#_9-5-example-insertion-cursor-and-selection"><span>9.5 Example: insertion cursor and selection</span></a></h2><p>The next sections work through two examples that illustrate the principles discussed above. In the first example the best approach is to separate the relevant pieces of code; in the second example it is better to join them together.</p><p>The first example consists of the insertion cursor and the selection in the GUI editor project from Chapter 6. The editor displays a blinking vertical line indicating where text typed by the user will appear in the document. It also displays a highlighted range of characters called the selection, which is used for copying or deleting text. The insertion cursor is always visible, but there are times when no text is selected. If the selection exists, the insertion cursor is always positioned at one end of it.</p><p>The selection and insertion cursor are related in some ways. For example, the cursor is always positioned at one end of the selection, and the cursor and selection tend to be manipulated together: clicking and dragging the mouse sets both of them, and text insertion first deletes the selected text, if there is any, and then inserts new text at the cursor position. Thus, it might seem logical to use a single object to manage both the selection and the cursor, and one project team took this approach. The object stored two positions in the file, along with booleans indicating which end was the cursor and whether the selection existed.</p><p>However, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text). The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separate entity, but instead had to store a boolean indicating which end of the selection was the cursor. In order to retrieve the cursor position, the combined object had to first test the boolean and then choose the appropriate end of the selection.</p><p>In this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler. Separate objects provided a simpler interface than a combined object from which selection and cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectly through a selection and a boolean. In fact, in the revised version no special classes were used for either the selection or the cursor. Instead, a new Position class was introduced to represent a location in the file (a line number and character within line). The selection was represented with two Positions and the cursor with one. Positions also found other uses in the project. This example also demonstrates the benefits of a lower-level but more general-purpose interface, which were discussed in Chapter 6.</p><p>img Red Flag: Special-General Mixture img</p><p>This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.</p><h2 id="_9-6-example-separate-class-for-logging" tabindex="-1"><a class="header-anchor" href="#_9-6-example-separate-class-for-logging"><span>9.6 Example: separate class for logging</span></a></h2><p>The second example involved error logging in a student project. A class contained several code sequences like the following:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    rpcConn <span class="token operator">=</span> connectionPool<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">NetworkErrorLogger</span><span class="token punctuation">.</span><span class="token function">logRpcOpenError</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Rather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked. The error logging class was defined at the end of the same source file:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NetworkErrorLogger</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
    *  Output information relevant to an error that occurs when trying
    *  to open a connection to send an RPC.
    *
    *  <span class="token keyword">@param</span> <span class="token parameter">req</span>
    *       The RPC request that would have been sent through the connection
    *  <span class="token keyword">@param</span> <span class="token parameter">dest</span>
    *       The destination of the RPC
    *  <span class="token keyword">@param</span> <span class="token parameter">e</span>
    *       The caught error
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">logRpcOpenError</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">AddrPortTuple</span> dest<span class="token punctuation">,</span> <span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;Cannot send message: &quot;</span> <span class="token operator">+</span> req <span class="token operator">+</span> <span class="token string">&quot;. \\n&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;Unable to find or open connection to &quot;</span> <span class="token operator">+</span> dest <span class="token operator">+</span> <span class="token string">&quot; :&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The NetworkErrorLogger class contained several methods such as logRpcSendError and logRpcReceiveError, each of which logged a different kind of error.</p><p>This separation added complexity with no benefit. The logging methods were shallow: most consisted of a single line of code, but they required a considerable amount of documentation. Each method was only invoked in a single place. The logging methods were highly dependent on their invocations: someone reading the invocation would most likely flip over to the logging method to make sure that the right information was being logged; similarly, someone reading the logging method would probably flip over to the invocation site to understand the purpose of the method.</p><p>In this example, it would be better to eliminate the logging methods and place the logging statements at the locations where the errors were detected. This would make the code easier to read and eliminate the interfaces required for the logging methods.</p><h2 id="_9-7-splitting-and-joining-methods" tabindex="-1"><a class="header-anchor" href="#_9-7-splitting-and-joining-methods"><span>9.7 Splitting and joining methods</span></a></h2><p>The issue of when to subdivide applies not just to classes, but also to methods: are there times when it is better to divide an existing method into multiple smaller methods? Or, should two smaller methods be combined into one larger one? Long methods tend to be more difficult to understand than shorter ones, so many people argue that length alone is a good justification for breaking up a method. Students in classes are often given rigid criteria, such as “Split up any method longer than 20 lines!”</p><p>However, length by itself is rarely a good reason for splitting up a method. In general, developers tend to break up methods too much. Splitting up a method introduces additional interfaces, which add to complexity. It also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related. You shouldn’t break up a method unless it makes the overall system simpler; I’ll discuss how this might happen below.</p><p>Long methods aren’t always bad. For example, suppose a method contains five 20-line blocks of code that are executed in order. If the blocks are relatively independent, then the method can be read and understood one block at a time; there’s not much benefit in moving each of the blocks into a separate method. If the blocks have complex interactions, it’s even more important to keep them together so readers can see all of the code at once; if each block is in a separate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundreds of lines of code are fine if they have a simple signature and are easy to read. These methods are deep (lots of functionality, simple interface), which is good.</p><p><img src="`+n+`" alt=""></p><p>Figure 9.3: A method (a) can be split either by by extracting a subtask (b) or by dividing its functionality into two separate methods (c). A method should not be split if it results in shallow methods, as in (d).</p><p>When designing methods, the most important goal is to provide clean abstractions. Each method should do one thing and do it completely. The method should have a simple interface, so that users don’t need to have much information in their heads in order to use it correctly. The method should be deep: its interface should be much simpler than its implementation. If a method has all of these properties, then it probably doesn’t matter whether it is long or not.</p><p>Splitting up a method only makes sense if it results in cleaner abstractions, overall. There are two ways to do this, which are diagrammed in Figure 9.3. The best way is by factoring out a subtask into a separate method, as shown in Figure 9.3(b). The subdivision results in a child method containing the subtask and a parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the original method. This form of subdivision makes sense if there is a subtask that is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesn’t need to know anything about the parent method and (b) someone reading the parent method doesn’t need to understand the implementation of the child method. Typically this means that the child method is relatively general-purpose: it could conceivably be used by other methods besides the parent. If you make a split of this form and then find yourself flipping back and forth between the parent and child to understand how they work together, that is a red flag (“Conjoined Methods”) indicating that the split was probably a bad idea.</p><p>The second way to break up a method is to split it into two separate methods, each visible to callers of the original method, as in Figure 9.3(c). This makes sense if the original method had an overly complex interface because it tried to do multiple things that were not closely related. If this is the case, it may be possible to divide the method’s functionality into two or more smaller methods, each of which has only a part of the original method’s functionality. If you make a split like this, the interface for each of the resulting methods should be simpler than the interface of the original method. Ideally, most callers should only need to invoke one of the two new methods; if callers must invoke both of the new methods, then that adds complexity, which makes it less likely that the split is a good idea. The new methods will be more focused in what they do. It is a good sign if the new methods are more general-purpose than the original method (i.e., you can imagine using them separately in other situations).</p><p>Splits of the form shown in Figure 9.3(c) don’t make sense very often, because they result in callers having to deal with multiple methods instead of one. When you split this way, you run the risk of ending up with several shallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods, passing state back and forth between them, then splitting is not a good idea. If you’re considering a split like the one in Figure 9.3(c), you should judge it based on whether it simplifies things for callers.</p><p>There are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it might eliminate dependencies between the original methods, or intermediate data structures; it might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place; or it might result in a simpler interface, as discussed in Section 9.2.</p><p>img Red Flag: Conjoined Methods img</p><p>It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.</p><h2 id="_9-8-a-different-opinion-clean-code" tabindex="-1"><a class="header-anchor" href="#_9-8-a-different-opinion-clean-code"><span>9.8 A different opinion: Clean Code</span></a></h2><p>In the book Clean Code1, Robert Martin argues that functions should be broken up based on length alone. He says that functions should be extremely short, and that even 10 lines is too long:</p><pre><code>The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that....Blocks within if statements, else statements, while statements, and so on should be one line long. Probably that line should be a function call.... This also implies that functions should not be large enough to hold nested structures. Therefore, the indent level of a function should not be greater than one or two. This, of course, makes the functions easier to read and understand.
</code></pre><p>I agree that shorter functions are generally easier to understand than longer ones. However, once a function gets down to a few dozen lines, further reductions in size are unlikely to have much impact on readability. A more important issue is: does breaking up a function reduce the overall complexity of the system? In other words, is it easier to read several short functions and understand how they work together than it is to read one larger function? More functions means more interfaces to document and learn. If functions are made too small, they lose their independence, resulting in conjoined functions that must be read and understood together. When this happens, then it’s better to keep the larger function, so all of the related code is one place. Depth is more important than length: first make functions deep, then try to make them short enough to be easily read. Don’t sacrifice depth for length.</p><h2 id="_9-9-conclusion" tabindex="-1"><a class="header-anchor" href="#_9-9-conclusion"><span>9.9 Conclusion</span></a></h2><p>The decision to split or join modules should be based on complexity. Pick the structure that results in the best information hiding, the fewest dependencies, and the deepest interfaces.</p><p>1Clean Code, Robert C. Martin, Pearson Education, Inc., Boston, MA 2009</p>`,59),h=[l];function d(c,p){return o(),s("div",null,h)}const f=a(r,[["render",d],["__file","ch09.html.vue"]]),g=JSON.parse('{"path":"/en/ch09.html","title":"Chapter 9 Better Together Or Better Apart?","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"9.1 Bring together if information is shared","slug":"_9-1-bring-together-if-information-is-shared","link":"#_9-1-bring-together-if-information-is-shared","children":[]},{"level":2,"title":"9.2 Bring together if it will simplify the interface","slug":"_9-2-bring-together-if-it-will-simplify-the-interface","link":"#_9-2-bring-together-if-it-will-simplify-the-interface","children":[]},{"level":2,"title":"9.3 Bring together to eliminate duplication","slug":"_9-3-bring-together-to-eliminate-duplication","link":"#_9-3-bring-together-to-eliminate-duplication","children":[]},{"level":2,"title":"9.4 Separate general-purpose and special-purpose code","slug":"_9-4-separate-general-purpose-and-special-purpose-code","link":"#_9-4-separate-general-purpose-and-special-purpose-code","children":[]},{"level":2,"title":"9.5 Example: insertion cursor and selection","slug":"_9-5-example-insertion-cursor-and-selection","link":"#_9-5-example-insertion-cursor-and-selection","children":[]},{"level":2,"title":"9.6 Example: separate class for logging","slug":"_9-6-example-separate-class-for-logging","link":"#_9-6-example-separate-class-for-logging","children":[]},{"level":2,"title":"9.7 Splitting and joining methods","slug":"_9-7-splitting-and-joining-methods","link":"#_9-7-splitting-and-joining-methods","children":[]},{"level":2,"title":"9.8 A different opinion: Clean Code","slug":"_9-8-a-different-opinion-clean-code","link":"#_9-8-a-different-opinion-clean-code","children":[]},{"level":2,"title":"9.9 Conclusion","slug":"_9-9-conclusion","link":"#_9-9-conclusion","children":[]}],"git":{"updatedTime":1710754240000},"filePathRelative":"en/ch09.md"}');export{f as comp,g as data};
